"""
Script# : 2

INPUT: Raw Data File generated by Amazon Seller Central Portal for a particular seller that has been fed as webpage input by registered User AND undergone 'ordersFile_parsing' script.
OUTPUT: Orders data as a Pandas DataFrame or TextParserself. Then renames columns for better readability, if they match our internal records.
"""

# Importing required libraries:
import numpy as np
import pandas as pd
from datetime import datetime
from datetime import date
from datetime import time
import holidays


# List of Holidays for India and America:
indian_days = {"2019, 1, 1":"New Year's Day", "2019, 1, 11":"Missionary Day[MZ]", "2019, 1, 12":"Swami Vivekananda Birthday[WB]", "2019, 1, 14":"Bhogi[TS]", "2019, 1, 14":"Pongal/Sankranti/Lohri/Bihu", "2019, 1, 15":"Tusu Puja[AS]", "2019, 1, 16":"Thirulallur Day[TN]", "2019, 1, 17":"Uzhavar Tirunal[PY,TN]", "2019, 1, 23":"Shubhas Chandra Bose Jayanti", "2019, 1, 25":"Sir Chhotu Ram Jayanti[HR] / Statehood Day[HP]", "2019, 1, 26":"Republic Day", "2019, 1, 31":"Me-dam-me-phi[AS]", "2019, 2, 5":"Sonam Lhochar/Losar[SK]", "2019, 2, 10":"Vasant Panchami", "2019, 2, 15":"Lui-Ngai-Ni[MN]", "2019, 2, 19":"Shivaji Maharaj Jayanti[MH] / Guru Ravidas Birthday[HR,HP,PB]", "2019, 2, 20":"Mizoram State Day[MZ]", "2019, 2, 28":"Maharshi Dayanand Saraswati Jayanti[HR]", "2019, 3, 4":"Maha Shivratri", "2019, 3, 20":"Hazrat Alis Birthday[UP]", "2019, 3, 21":"Holi", "2019, 3, 21":"Yaosang 2nd Day[MN]", "2019, 3, 22":"Bihar Divas[BR]", "2019, 3, 23":"Shaheed Divas[HR]", "2019, 4, 1":"Bank Holiday", "2019, 4, 1":"Utkal Divas[OR]", "2019, 4, 6":"Ugadi/Gudi Padwa[MH]/Sajibu Nongmapanba[MN]", "2019, 4, 7":"Cheti Chand[GJ]", "2019, 4, 13":"Biju[TR]", "2019, 4, 14":"Ram Navami/Bohag Bihu[AS,AS,AR]", "2019, 4, 17":"Mahavir Jayanti", "2019, 4, 19":"Good Friday", "2019, 5, 1":"May Day", "2019, 5, 19":"Buddha Purnima", "2019, 5, 31":"Jumat-ul-Wida", "2019, 6, 5":"Idul Fitr", "2019, 6, 14":"Pahili Raja[OR]", "2019, 6, 17":"Sant Guru Kabir Jayanti[HR,HP,PB]", "2019, 6, 23":"Kharchi Puja[TR]", "2019, 6, 30":"Remna Ni[MZ]", "2019, 7, 4":"Ratha Yatra[OR]", "2019, 7, 5":"Guru Hargobind's Birthday[JK]", "2019, 7, 7":"Ker Puja[TR]", "2019, 7, 17":"U Tirot Sing Day[ML]", "2019, 7, 31":"Karkkadaka Vavu[KL]", "2019, 8, 12":"Bakrid/Idul Juha", "2019, 8, 15":"Independence Day", "2019, 8, 17":"Jamshed Navroz[GJ,MH]", "2019, 8, 24":"Janmashtmi", "2019, 9, 1":"Muharram/Teej[HR]", "2019, 9, 2":"Ganesh Chaturthi", "2019, 9, 10":"First Onam/Muharram (10th Day)", "2019, 9, 11":"Thiruvonam[KL]", "2019, 9, 12":"Saragarhi Day[PB]", "2019, 9, 29":"Mahalaya", "2019, 10, 2":"Gandhi Jayanti", "2019, 10, 5":"Maha Saptami", "2019, 10, 6":"Durgastami/Mahanavmi", "2019, 10, 8":"Dussehra", "2019, 10, 13":"Valmiki Birthday", "2019, 10, 27":"Deepavali/Kali Puja", "2019, 10, 28":"Vishvakarma Puja", "2019, 10, 29":"Lakshmi Puja", "2019, 10, 29":"Bhai Bij[GJ]", "2019, 10, 30":"Ningol Chakkouba[MN]", "2019, 11, 1":"Haryana Day[HR]/Kannada Rajyothsava[KA]", "2019, 11, 2":"Chhath Puja", "2019, 11, 10":"Id-e-Milad", "2019, 11, 12":"Guru Nanak Birthday", "2019, 11, 23":"Seng Kut Snem[ML]", "2019, 11, 26":"Narak Chaturdashi[KA]", "2019, 12, 2":"Asom Diwas[AS]", "2019, 12, 3":"World Disabled Day[TR]", "2019, 12, 5":"Sheikh Mohammad Abdullah Birthday", "2019, 12, 12":"Pa Togan Nengminja Sangma", "2019, 12, 25":"Christmas", "2019, 12, 26":"Martyor Udham Singh Day[HR]", "2019, 12, 30":"U Kiang Nangbah[ML]", "2019, 12, 31":"Last day of Gregorian Calendar"}

american_days = {"2019, 1, 1":"New Year's Day", "2019, 1, 21":"Martin Luther King Jr. Day", "2019, 2, 18":"President's Day","2019, 4, 16":"Emancipation Day[DC]", "2019, 5, 12":"Mother's Day", "2019, 5, 27":"Memorial Day", "2019, 6, 16":"Father's Day", "2019, 7, 4":"Independence Day", "2019, 9, 2":"Labor Day", "2019, 10, 14":"Columbus Day", "2019, 11, 11":"Veteran's Day", "2019, 11, 28":"Thanksgiving Day", "2019, 12, 25":"Christmas"}


# Creating dictionary of values to replace/use in determining 'phase_of_day':
hour_categories_day = {0:"Night",1:"Night",2:"Night",3:"Night",4:"Night",5:"Night",6:"Morning",7:"Morning",8:"Morning",9:"Morning",10:"Morning",11:"Morning",12:"Afternoon",13:"Afternoon",14:"Afternoon",15:"Afternoon",16:"Afternoon",17:"Evening",18:"Evening",19:"Evening",20:"Evening",21:"Evening",22:"Evening",23:"Night"}

## Eliminating empty and duplicate rows from input data table, if any:
def data_sanity_check(data, inplace=True):
    """
    DOCSTRING: Eliminates viewing of empty and duplicate rows from input DataFrame based on repeated 'Order ID' and 'Order Item ID', if any. But those empty rows still hold their Index position as we are only excluding them ffrom future operations, once passed through this operation.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.
    > inplace: Optional Boolean (True/False) parameter. By default it is set to True and is ideally not expected to be modified unless critical. If set to False, only a Dataframe replica get modified.

    OUTPUT:
    Deduplicated DataFrame (without duplicates or any rows that had no value/records).
    """
    # Checking for duplicates:
    data.drop_duplicates(subset=["Order ID", "Order Item ID"], keep="first", inplace=inplace)
    # Checking if any column has all empty rows, and removing those:
    data.dropna(axis=1, how="all", inplace=inplace)
    return data


## Treating binary/multi-categorical feature columns as well as numerical columns:
def data_substitution(data, inplace=True):
    """
    DOCSTRING: Eliminates empty and duplicate rows from input DataFrame based on repeated 'Order ID', if any. Example: 'COD' or 'Online' payment method.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.
    > inplace: Optional Boolean (True/False) parameter. By default it is set to True and is ideally not expected to be modified unless critical. If set to False, only a Dataframe replica get modified.

    OUTPUT:
    Pandas DataFrame without duplicates or any rows that had no value/records.
    """
    # Replacing empty rows in 'Payment Method' column with 'Online'. Due to issues, replacing entire dataset with this values that shall be slowly sorted out in further section of this and other scripts:
    data = data.fillna("Online", inplace=inplace)
    # Better way would be:
    #data["col_name"].replace(" ", "Online", inplace=True)
    """
    # [FAILED] Replacing 'Is Business Order' with 'No' if False or no input:
    #data["Is Business Order"].replace(False, 0, inplace=True)
    # More to be added as per requirements.
    """
    return data


## Treating binary/multi-categorical feature columns as well as numerical columns:
def day_of_week(data):
    """
    DOCSTRING: Concludes Purchase and Payments calendar day for each transaction, based on 'Purchase UTC DateTime' and 'Payments UTC DateTime'. Amazon provides DateTime in UTC ISO format when downloaded. Script is effective even if Amazon provides localized DateTime later on.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.

    OUTPUT:
    Pandas DataFrame with 2 new columns encompassing Localized (aware) Day of week for 'Purchase' and 'Payment' of every transaction.
    """
    # Converting 'Purchase UTC DateTime' and 'Payment UTC DateTime' to DateTime objects before extracting weekdays:
    data["Purchase UTC DateTime"] = pd.to_datetime(data["Purchase UTC DateTime"], format="%Y-%m-%d %H:%M:%S")
    data["Payment UTC DateTime"] = pd.to_datetime(data["Payment UTC DateTime"], format="%Y-%m-%d %H:%M:%S")
    #weekday_notation = {0:"Monday",1:"Tuesday",2:"Wednesday",3:"Thursday",4:"Friday",5:"Saturday",6:"Sunday"}
    data["Purchase Day"] = data["Purchase UTC DateTime"].dt.day_name()
    data["Payment Day"] = data["Payment UTC DateTime"].dt.day_name()
    return data


#
def phase_of_day(data):
    """
    DOCSTRING: Furnishes purchase phase of day, segregated into following 4 categories - [Morning, Afternoon, Evening, Night]. Calculation interval is of 6 hours, starting from Morning at 06:00 AM. Amazon provides DateTime in UTC ISO format when downloaded. Script is effective even if Amazon provides localized DateTime later on.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.

    OUTPUT:
    Pandas DataFrame or TextParser with 2 new columns encompassing Localized (aware) Day of week for 'Purchase' and 'Payment' of every transaction.
    """
    data["Purchase Hour"] = pd.to_datetime(data["Purchase Time"], format="%H:%M:%S").dt.hour
    data["Payment Hour"] = pd.to_datetime(data["Payment Time"], format="%H:%M:%S").dt.hour
    data["Phase of Day"] = np.nan
    # As per 'Purchase Hour', assigning phase of day:
    for i,v in data["Purchase Hour"].iteritems():
        if v in list(hour_categories_day.copy().keys()):
            data.loc[i, "Phase of Day"] = hour_categories_day[v]
    return data


## Computing Total Earnings for Seller:
def total_earnings(data):
    """
    DOCSTRING: Computes Total earnings of a Seller per transaction as 'Selling Price'. Calculation involves (Item Price+Taxes+Additional Charges) - (Total Discounts). Two additional columns created as 'Discounts' and 'Addl. Charges'. Two additional columns created for HTML Table, namely 'Total Earnings' that has Currency added, and 'States' column with country abbreviation added in it.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.

    OUTPUT:
    Pandas DataFrame or TextParser with 2 new columns encompassing Localized (aware) Day of week for 'Purchase' and 'Payment' of every transaction.
    """
    # Computation of additional charges and Discounts on each item:
    taxes = pd.Series(data= (data["Item Tax"] + data["Shipping Price"] + data["Shipping Tax"])).round(2)
    discounts = pd.Series(data= (data["Item Discount"] + data["Shipping Discount"])).round(2)
    # Computation of Selling Price for each Item/Record:
    SP = pd.Series(data= ((data["Item Price"] + taxes) - discounts)).round(2)
    # Creating 3 new numerical columns for each of above:
    data.insert(loc=40, column="Selling Price", value=SP)
    data.insert(loc=41, column="Discounts", value=discounts)
    data.insert(loc=42, column="Addl. Charges", value=taxes)
    # Adding Currency value to reformed Pricing Columns for HTML Table representation:
    for i,v in data["Currency"].iteritems():
        if v == "Online":
            data["Total Earning"] = data["Selling Price"].astype(str)
        else:
            data["Total Earning"] = data["Currency"] + " " + data["Selling Price"].astype(str)
    # [OUT OF CONTEXT] 'States' column being added for HTML Table with Country code:
    data["States"] = data["Country"] + "-" + data['State']
    return data


def month_and_festivals(data):
    """
    DOCSTRING: Creates a 'Month' column along with a list of feativals based on 'Purchase UTC DateTime', with reference to 'Purchase Date'. Additionally 'Holiday' column gets created with national holidays currently for India and North America.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.

    OUTPUT:
    Pandas DataFrame or TextParser with 2 new columns encompassing Months of respective year and Festivals.
    """
    # Extracting Month name (not localized):
    data["Month"] = data["Purchase UTC DateTime"].dt.month_name()
    # Acknowledging Global Festivities and Holidays for Customers on Purchase Date. Countries covered include: [India and North America]:
    data["Holiday"] = np.nan
    # Dictionary items would require update down the lane:
    country_iso_codes = holidays.IND() + holidays.US()
    for i,v in data["Purchase Date"].iteritems():
        if v in country_iso_codes:
            data.loc[i, "Holiday"] = country_iso_codes[v]
    """
    # [INFO] Failed to use personalized 'indian_days' and 'american_days' list of holidays:
    for i,v in data["Purchase Date"].iteritems():
        if data.loc[i, "Country"] == "IN":
            if v in indian_days:
                data.loc[i, "Holiday"] = indian_days[v]
        elif data.loc[i, "Country"] == "US":
            if v in american_days:
                data.loc[i, "Holiday"] = american_days[v]
        else:
            country_iso_codes = holidays.IND() + holidays.US() + holidays.CA()
            if v in country_iso_codes:
                data.loc[i, "Holiday"] = country_iso_codes[v]
    """
    return data


# Ascertaining whether a Weekday or a Weekend:
def weekday_end(data):
    """
    DOCSTRING: Creates a 'Week day/end' column based on 'Purchase Day' column, to assist plotting computations.
    INPUT:
    > data : Only accepts Pandas DataFrame or TextParser.

    OUTPUT:
    Pandas DataFrame or TextParser with a new column added for ascertaining whether Purchase Date was a weekday or weekend.
    """
    data["Week day/end"] = np.nan
    for i,v in data["Purchase Day"].iteritems():
        if v in ["Saturday", "Sunday"]:
            data.loc[i, "Week day/end"] = "Weekends"
        else:
            data.loc[i, "Week day/end"] = "Weekdays"
    return data
